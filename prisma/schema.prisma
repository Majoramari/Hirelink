// HireLink Prisma schema.
//
// This file defines:
// - The Prisma Client generator, how and where Prisma Client is generated.
// - The data source, which database Prisma uses.
// - Domain enums, limited sets of values used by models.
// - Models, including fields, relations, defaults, indexes, and constraints
//
// Conventions used throughout:
// - id fields are ULIDs generated by the application (Not prisma).
// - Most child records are deleted automatically using onDelete: Cascade.
//
// Notes:
// - Prisma Client is generated into src/generated/prisma (see generator output).
// - With Prisma 7, some command-line settings (data source URL, seed command) live in prisma.config.ts.
//
// References:
// - Schema reference: https://www.prisma.io/docs/orm/reference/prisma-config-reference#schema
// - Prisma configuration: https://www.prisma.io/docs/orm/reference/prisma-config-reference

generator client {
  provider   = "prisma-client"
  // Output is kept inside the application source tree for stable import paths.
  // Note: its gitignored, generate it using `npm run prisma:generate` .
  output     = "../src/generated/prisma"
  engineType = "client"
}

datasource db {
  provider = "postgresql"
}

enum Role {
  // Decides which profile Talent/Employer a User has.
  TALENT
  EMPLOYER
  MODERATOR // Doesn't have a profile.
}

enum JobType {
  // High-level employment type for a Job.
  FULL_TIME
  PART_TIME
  INTERNSHIP
}

enum ExperienceLevel {
  // Desired experience for a Job.
  FRESH
  JUNIOR
  SENIOR
  LEAD
}

enum ApplicationStatus {
  APPLIED
  REJECTED
  HIRED
}

enum LanguageProficiency {
  // Shared experience for both talent languages and job language requirements.
  BASIC
  INTERMEDIATE
  ADVANCED
  NATIVE
}

enum SkillLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
  MASTER
}

model User {
  // Core authentication.
  // A user can have either a Talent or Employer profile
  id       String  @id // ULID generated by the application
  email    String  @unique
  // Hashed by bcrypt password
  password String
  // Mainly to disable the account via a Moderator
  isActive Boolean @default(true)
  // Determines which profile should exist and how the permissions behave.
  role     Role

  // Relations to role-specific profiles
  talentProfile   Talent?
  employerProfile Employer?

  // Tokens
  // Refresh tokens are stored server-side so they can be revoked or rotated.
  // Note: this could be hard to understand, just ask me for any explaination or read about JWT rotation
  refreshTokens         RefreshToken[] @relation("UserRefreshTokens")
  isEmailVerified       Boolean        @default(false)
  // Email verification uses a token + expiry stored on the user.
  verificationToken     String?
  verificationExpiresAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Indexes optimize lookups by common query filters.
  // Note: this an optimization it helps with searching by email or role (make it faster)
  @@index([email])
  @@index([role])
}

model RefreshToken {
  // Persisted refresh token for a user session.
  // Tokens can be revoked and rotated; a self-relation tracks replacement chains.
  id           String    @id // ULID generated by the application
  token        String    @unique
  userId       String
  user         User      @relation("UserRefreshTokens", fields: [userId], references: [id], onDelete: Cascade)
  createdAt    DateTime  @default(now())
  expiresAt    DateTime
  revoked      Boolean   @default(false)
  revokedAt    DateTime?
  replacedById String?

  // This is a self-relation that lets us track a chain of token replacements.
  // One token can be replaced by another token, and that new token can also be replaced later.
  // This helps us revoke a token and also invalidate the tokens that came after it.
  // The relation is optional, so a token can exist without being replaced.
  // `replacedById` and `replacedTokens` are used to store the replacement chain.
  // `replacedById` points to the `id` of another `RefreshToken`.
  // `replacedTokens` lists the `RefreshToken` records that this token replaced.
  replacedBy     RefreshToken?  @relation("TokenReplacement", fields: [replacedById], references: [id], onDelete: SetNull)
  replacedTokens RefreshToken[] @relation("TokenReplacement")

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

model Talent {
  // Role-specific profile for users with `Role.TALENT`.
  // Separate model keeps auth concerns (`User`) distinct from profile data.
  id     String @id // ULID generated by the application (same as User.id)
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Basic profile information.
  firstName      String?
  lastName       String?
  headline       String?
  bio            String? @db.VarChar(1000)
  location       String?
  // Public IDs for files stored in an external asset store (Cloudinary).
  avatarPublicId String?
  resumePublicId String?

  // Relations
  // Join models allow attaching metadata (skill level, language proficiency).
  skills       TalentSkill[]       @relation("TalentSkills")
  languages    TalentLanguage[]    @relation("TalentLanguages")
  certificates TalentCertificate[]
  // Applications submitted by this talent.
  applications Application[]       @relation("TalentApplications")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

model Employer {
  // Role-specific profile for users with `Role.EMPLOYER`.
  id     String @id // ULID generated by the application (same as User.id)
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Company information displayed on job posts.
  companyName    String
  website        String?
  description    String? @db.VarChar(1000)
  location       String?
  avatarPublicId String?

  // Relations
  // Jobs posted by this employer.
  jobs Job[] @relation("EmployerJobs")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([companyName])
}

model Job {
  // A job posting created by an employer.
  id         String   @id // ULID generated by the application
  employerId String
  employer   Employer @relation("EmployerJobs", fields: [employerId], references: [id], onDelete: Cascade)

  title            String
  description      String          @db.Text
  responsibilities String[]        @default([])
  location         String?
  jobType          JobType
  experienceLevel  ExperienceLevel
  hoursPerWeek     Int?
  salary           Int?
  // I added this field to make it easier for you to add drafts later if you wish to
  publishedAt      DateTime        @default(now())

  // Relations
  // Join models store requirements
  requiredSkills    JobSkill[]    @relation("JobRequiredSkills")
  requiredLanguages JobLanguage[] @relation("JobRequiredLanguages")
  // Applications submitted to this job.
  applications      Application[] @relation("JobApplications")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([employerId])
  @@index([jobType])
  @@index([experienceLevel])
}

model JobSkill {
  id       String  @id // ULID generated by the application
  jobId    String
  skillId  String
  required Boolean @default(true) // true = required, false = nice to have

  job   Job   @relation("JobRequiredSkills", fields: [jobId], references: [id], onDelete: Cascade)
  skill Skill @relation("JobSkills", fields: [skillId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  // Prevent duplicate skill entries for a given job.
  @@unique([jobId, skillId])
  @@index([skillId])
}

model JobLanguage {
  // Join model between `Job` and `Language`.
  // Stores minimum proficiency requirements for applicants.
  id                 String              @id // ULID generated by the application
  jobId              String
  languageId         String
  minimumProficiency LanguageProficiency // Minimum required proficiency level
  required           Boolean             @default(true)

  job      Job      @relation("JobRequiredLanguages", fields: [jobId], references: [id], onDelete: Cascade)
  language Language @relation("JobLanguages", fields: [languageId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  // Prevent duplicate language entries for a given job.
  @@unique([jobId, languageId])
  @@index([languageId])
}

model Application {
  // A talent's application to a job.
  // Ensures a talent can apply to the same job only once.
  id       String @id // ULID generated by the application
  jobId    String
  job      Job    @relation("JobApplications", fields: [jobId], references: [id], onDelete: Cascade)
  talentId String
  talent   Talent @relation("TalentApplications", fields: [talentId], references: [id], onDelete: Cascade)

  // Applicant-provided content.
  coverLetter String?           @db.Text
  // Optional external/hosted resume link (separate from `Talent.resumePublicId`).
  resumeUrl   String?
  status      ApplicationStatus @default(APPLIED)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([jobId, talentId])
  @@index([talentId])
  @@index([jobId])
}

model Skill {
  // Main list of skills used for matching jobs and talents.
  id             String   @id // ULID generated by the application
  name           String   @unique
  // Optional normalized version (for example, lowercased and trimmed) to prevent duplicates and support matching.
  normalizedName String?  @unique
  createdAt      DateTime @default(now())

  // Back-relations to join models.
  talents TalentSkill[] @relation("SkillTalents")
  jobs    JobSkill[]    @relation("JobSkills")
}

model TalentSkill {
  // Join model between `Talent` and `Skill`, including the talent's level.
  id        String     @id // ULID generated by the application
  talentId  String
  skillId   String
  level     SkillLevel
  createdAt DateTime   @default(now())

  talent Talent @relation("TalentSkills", fields: [talentId], references: [id], onDelete: Cascade)
  skill  Skill  @relation("SkillTalents", fields: [skillId], references: [id], onDelete: Cascade)

  // Prevent duplicate skill entries for a given talent.
  @@unique([talentId, skillId])
  @@index([skillId])
}

model Language {
  // Main list of languages used for both talent profiles and job requirements.
  id             String   @id // ULID generated by the application
  name           String   @unique
  // Optional normalized version for matching and preventing duplicates.
  normalizedName String?  @unique
  createdAt      DateTime @default(now())

  // Back-relations to join models.
  talents TalentLanguage[] @relation("TalentLanguages")
  jobs    JobLanguage[]    @relation("JobLanguages")
}

model TalentLanguage {
  // Join model between `Talent` and `Language`, including proficiency.
  id          String              @id // ULID generated by the application
  talentId    String
  languageId  String
  proficiency LanguageProficiency
  createdAt   DateTime            @default(now())

  talent   Talent   @relation("TalentLanguages", fields: [talentId], references: [id], onDelete: Cascade)
  language Language @relation("TalentLanguages", fields: [languageId], references: [id], onDelete: Cascade)

  // Prevent duplicate language entries for a given talent.
  @@unique([talentId, languageId])
  @@index([languageId])
}

model TalentCertificate {
  id            String    @id // ULID generated by the application
  talentId      String
  name          String
  issuer        String
  credentialUrl String?
  credentialId  String?
  issueDate     DateTime?
  expiryDate    DateTime?
  createdAt     DateTime  @default(now())

  talent Talent @relation(fields: [talentId], references: [id], onDelete: Cascade)

  @@index([talentId])
}
